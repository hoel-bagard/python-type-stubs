"""
This type stub file was generated by pyright.
"""

from typing import Any, Dict, List, Optional, Sequence, Tuple, Union

import numpy as np

from ...core.transforms_interface import BoxInternalType, DualTransform, KeypointInternalType

__all__ = ["RandomCrop", "CenterCrop", "Crop", "CropNonEmptyMaskIfExists", "RandomSizedCrop", "RandomResizedCrop", "RandomCropNearBBox", "RandomSizedBBoxSafeCrop", "CropAndPad", "RandomCropFromBorders", "BBoxSafeRandomCrop"]
class RandomCrop(DualTransform):
    """Crop a random part of the input.

    Args:
        height (int): height of the crop.
        width (int): width of the crop.
        p (float): probability of applying the transform. Default: 1.

    Targets:
        image, mask, bboxes, keypoints

    Image types:
        uint8, float32
    """
    def __init__(self, height, width, always_apply=..., p=...) -> None:
        ...
    
    def apply(self, img, h_start=..., w_start=..., **params): # -> ndarray[Unknown, Unknown]:
        ...
    
    def get_params(self): # -> dict[str, float]:
        ...
    
    def apply_to_bbox(self, bbox, **params): # -> BoxInternalType:
        ...
    
    def apply_to_keypoint(self, keypoint, **params): # -> tuple[float, float, float, float]:
        ...
    
    def get_transform_init_args_names(self): # -> tuple[Literal['height'], Literal['width']]:
        ...
    


class CenterCrop(DualTransform):
    """Crop the central part of the input.

    Args:
        height (int): height of the crop.
        width (int): width of the crop.
        p (float): probability of applying the transform. Default: 1.

    Targets:
        image, mask, bboxes, keypoints

    Image types:
        uint8, float32

    Note:
        It is recommended to use uint8 images as input.
        Otherwise the operation will require internal conversion
        float32 -> uint8 -> float32 that causes worse performance.
    """
    def __init__(self, height, width, always_apply=..., p=...) -> None:
        ...
    
    def apply(self, img, **params): # -> ndarray[Unknown, Unknown]:
        ...
    
    def apply_to_bbox(self, bbox, **params): # -> BoxInternalType:
        ...
    
    def apply_to_keypoint(self, keypoint, **params): # -> tuple[float, float, float, float]:
        ...
    
    def get_transform_init_args_names(self): # -> tuple[Literal['height'], Literal['width']]:
        ...
    


class Crop(DualTransform):
    """Crop region from image.

    Args:
        x_min (int): Minimum upper left x coordinate.
        y_min (int): Minimum upper left y coordinate.
        x_max (int): Maximum lower right x coordinate.
        y_max (int): Maximum lower right y coordinate.

    Targets:
        image, mask, bboxes, keypoints

    Image types:
        uint8, float32
    """
    def __init__(self, x_min=..., y_min=..., x_max=..., y_max=..., always_apply=..., p=...) -> None:
        ...
    
    def apply(self, img, **params): # -> ndarray[Any, Unknown]:
        ...
    
    def apply_to_bbox(self, bbox, **params): # -> BoxInternalType:
        ...
    
    def apply_to_keypoint(self, keypoint, **params): # -> tuple[float, float, float, float]:
        ...
    
    def get_transform_init_args_names(self): # -> tuple[Literal['x_min'], Literal['y_min'], Literal['x_max'], Literal['y_max']]:
        ...
    


class CropNonEmptyMaskIfExists(DualTransform):
    """Crop area with mask if mask is non-empty, else make random crop.

    Args:
        height (int): vertical size of crop in pixels
        width (int): horizontal size of crop in pixels
        ignore_values (list of int): values to ignore in mask, `0` values are always ignored
            (e.g. if background value is 5 set `ignore_values=[5]` to ignore)
        ignore_channels (list of int): channels to ignore in mask
            (e.g. if background is a first channel set `ignore_channels=[0]` to ignore)
        p (float): probability of applying the transform. Default: 1.0.

    Targets:
        image, mask, bboxes, keypoints

    Image types:
        uint8, float32
    """
    def __init__(self, height, width, ignore_values=..., ignore_channels=..., always_apply=..., p=...) -> None:
        ...
    
    def apply(self, img, x_min=..., x_max=..., y_min=..., y_max=..., **params): # -> ndarray[Any, Unknown]:
        ...
    
    def apply_to_bbox(self, bbox, x_min=..., x_max=..., y_min=..., y_max=..., **params): # -> BoxInternalType:
        ...
    
    def apply_to_keypoint(self, keypoint, x_min=..., x_max=..., y_min=..., y_max=..., **params): # -> tuple[float, float, float, float]:
        ...
    
    def update_params(self, params, **kwargs): # -> Dict[str, Any]:
        ...
    
    def get_transform_init_args_names(self): # -> tuple[Literal['height'], Literal['width'], Literal['ignore_values'], Literal['ignore_channels']]:
        ...
    


class _BaseRandomSizedCrop(DualTransform):
    def __init__(self, height, width, interpolation=..., always_apply=..., p=...) -> None:
        ...
    
    def apply(self, img, crop_height=..., crop_width=..., h_start=..., w_start=..., interpolation=..., **params): # -> ndarray[Unknown, Unknown]:
        ...
    
    def apply_to_bbox(self, bbox, crop_height=..., crop_width=..., h_start=..., w_start=..., rows=..., cols=..., **params): # -> BoxInternalType:
        ...
    
    def apply_to_keypoint(self, keypoint, crop_height=..., crop_width=..., h_start=..., w_start=..., rows=..., cols=..., **params): # -> KeypointInternalType:
        ...
    


class RandomSizedCrop(_BaseRandomSizedCrop):
    """Crop a random part of the input and rescale it to some size.

    Args:
        min_max_height ((int, int)): crop size limits.
        height (int): height after crop and resize.
        width (int): width after crop and resize.
        w2h_ratio (float): aspect ratio of crop.
        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:
            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.
            Default: cv2.INTER_LINEAR.
        p (float): probability of applying the transform. Default: 1.

    Targets:
        image, mask, bboxes, keypoints

    Image types:
        uint8, float32
    """
    def __init__(self, min_max_height, height, width, w2h_ratio=..., interpolation=..., always_apply=..., p=...) -> None:
        ...
    
    def get_params(self): # -> dict[str, float | int]:
        ...
    
    def get_transform_init_args_names(self): # -> tuple[Literal['min_max_height'], Literal['height'], Literal['width'], Literal['w2h_ratio'], Literal['interpolation']]:
        ...
    


class RandomResizedCrop(_BaseRandomSizedCrop):
    """Torchvision's variant of crop a random part of the input and rescale it to some size.

    Args:
        height (int): height after crop and resize.
        width (int): width after crop and resize.
        scale ((float, float)): range of size of the origin size cropped
        ratio ((float, float)): range of aspect ratio of the origin aspect ratio cropped
        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:
            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.
            Default: cv2.INTER_LINEAR.
        p (float): probability of applying the transform. Default: 1.

    Targets:
        image, mask, bboxes, keypoints

    Image types:
        uint8, float32
    """
    def __init__(self, height, width, scale=..., ratio=..., interpolation=..., always_apply=..., p=...) -> None:
        ...
    
    def get_params_dependent_on_targets(self, params): # -> dict[str, int | Any]:
        ...
    
    def get_params(self): # -> dict[Unknown, Unknown]:
        ...
    
    @property
    def targets_as_params(self): # -> list[str]:
        ...
    
    def get_transform_init_args_names(self): # -> tuple[Literal['height'], Literal['width'], Literal['scale'], Literal['ratio'], Literal['interpolation']]:
        ...
    


class RandomCropNearBBox(DualTransform):
    """Crop bbox from image with random shift by x,y coordinates

    Args:
        max_part_shift (float, (float, float)): Max shift in `height` and `width` dimensions relative
            to `cropping_bbox` dimension.
            If max_part_shift is a single float, the range will be (max_part_shift, max_part_shift).
            Default (0.3, 0.3).
        cropping_box_key (str): Additional target key for cropping box. Default `cropping_bbox`
        p (float): probability of applying the transform. Default: 1.

    Targets:
        image, mask, bboxes, keypoints

    Image types:
        uint8, float32

    Examples:
        >>> aug = Compose([RandomCropNearBBox(max_part_shift=(0.1, 0.5), cropping_box_key='test_box')],
        >>>              bbox_params=BboxParams("pascal_voc"))
        >>> result = aug(image=image, bboxes=bboxes, test_box=[0, 5, 10, 20])

    """
    def __init__(self, max_part_shift: Union[float, Tuple[float, float]] = ..., cropping_box_key: str = ..., always_apply: bool = ..., p: float = ...) -> None:
        ...
    
    def apply(self, img: np.ndarray, x_min: int = ..., x_max: int = ..., y_min: int = ..., y_max: int = ..., **params) -> np.ndarray:
        ...
    
    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -> Dict[str, int]:
        ...
    
    def apply_to_bbox(self, bbox: BoxInternalType, **params) -> BoxInternalType:
        ...
    
    def apply_to_keypoint(self, keypoint: Tuple[float, float, float, float], x_min: int = ..., x_max: int = ..., y_min: int = ..., y_max: int = ..., **params) -> Tuple[float, float, float, float]:
        ...
    
    @property
    def targets_as_params(self) -> List[str]:
        ...
    
    def get_transform_init_args_names(self) -> Tuple[str]:
        ...
    


class BBoxSafeRandomCrop(DualTransform):
    """Crop a random part of the input without loss of bboxes.
    Args:
        erosion_rate (float): erosion rate applied on input image height before crop.
        p (float): probability of applying the transform. Default: 1.
    Targets:
        image, mask, bboxes
    Image types:
        uint8, float32
    """
    def __init__(self, erosion_rate=..., always_apply=..., p=...) -> None:
        ...
    
    def apply(self, img, crop_height=..., crop_width=..., h_start=..., w_start=..., **params): # -> ndarray[Unknown, Unknown]:
        ...
    
    def get_params_dependent_on_targets(self, params): # -> dict[str, float | Any | int] | dict[str, Any | int]:
        ...
    
    def apply_to_bbox(self, bbox, crop_height=..., crop_width=..., h_start=..., w_start=..., rows=..., cols=..., **params): # -> BoxInternalType:
        ...
    
    @property
    def targets_as_params(self): # -> list[str]:
        ...
    
    def get_transform_init_args_names(self): # -> tuple[Literal['erosion_rate']]:
        ...
    


class RandomSizedBBoxSafeCrop(BBoxSafeRandomCrop):
    """Crop a random part of the input and rescale it to some size without loss of bboxes.
    Args:
        height (int): height after crop and resize.
        width (int): width after crop and resize.
        erosion_rate (float): erosion rate applied on input image height before crop.
        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:
            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.
            Default: cv2.INTER_LINEAR.
        p (float): probability of applying the transform. Default: 1.
    Targets:
        image, mask, bboxes
    Image types:
        uint8, float32
    """
    def __init__(self, height, width, erosion_rate=..., interpolation=..., always_apply=..., p=...) -> None:
        ...
    
    def apply(self, img, crop_height=..., crop_width=..., h_start=..., w_start=..., interpolation=..., **params): # -> ndarray[Unknown, Unknown]:
        ...
    
    def get_transform_init_args_names(self): # -> tuple[Literal['erosion_rate'], Literal['height'], Literal['width'], Literal['interpolation']]:
        ...
    


class CropAndPad(DualTransform):
    """Crop and pad images by pixel amounts or fractions of image sizes.
    Cropping removes pixels at the sides (i.e. extracts a subimage from a given full image).
    Padding adds pixels to the sides (e.g. black pixels).
    This transformation will never crop images below a height or width of ``1``.

    Note:
        This transformation automatically resizes images back to their original size. To deactivate this, add the
        parameter ``keep_size=False``.

    Args:
        px (int or tuple):
            The number of pixels to crop (negative values) or pad (positive values)
            on each side of the image. Either this or the parameter `percent` may
            be set, not both at the same time.
                * If ``None``, then pixel-based cropping/padding will not be used.
                * If ``int``, then that exact number of pixels will always be cropped/padded.
                * If a ``tuple`` of two ``int`` s with values ``a`` and ``b``,
                  then each side will be cropped/padded by a random amount sampled
                  uniformly per image and side from the interval ``[a, b]``. If
                  however `sample_independently` is set to ``False``, only one
                  value will be sampled per image and used for all sides.
                * If a ``tuple`` of four entries, then the entries represent top,
                  right, bottom, left. Each entry may be a single ``int`` (always
                  crop/pad by exactly that value), a ``tuple`` of two ``int`` s
                  ``a`` and ``b`` (crop/pad by an amount within ``[a, b]``), a
                  ``list`` of ``int`` s (crop/pad by a random value that is
                  contained in the ``list``).
        percent (float or tuple):
            The number of pixels to crop (negative values) or pad (positive values)
            on each side of the image given as a *fraction* of the image
            height/width. E.g. if this is set to ``-0.1``, the transformation will
            always crop away ``10%`` of the image's height at both the top and the
            bottom (both ``10%`` each), as well as ``10%`` of the width at the
            right and left.
            Expected value range is ``(-1.0, inf)``.
            Either this or the parameter `px` may be set, not both
            at the same time.
                * If ``None``, then fraction-based cropping/padding will not be
                  used.
                * If ``float``, then that fraction will always be cropped/padded.
                * If a ``tuple`` of two ``float`` s with values ``a`` and ``b``,
                  then each side will be cropped/padded by a random fraction
                  sampled uniformly per image and side from the interval
                  ``[a, b]``. If however `sample_independently` is set to
                  ``False``, only one value will be sampled per image and used for
                  all sides.
                * If a ``tuple`` of four entries, then the entries represent top,
                  right, bottom, left. Each entry may be a single ``float``
                  (always crop/pad by exactly that percent value), a ``tuple`` of
                  two ``float`` s ``a`` and ``b`` (crop/pad by a fraction from
                  ``[a, b]``), a ``list`` of ``float`` s (crop/pad by a random
                  value that is contained in the list).
        pad_mode (int): OpenCV border mode.
        pad_cval (number, Sequence[number]):
            The constant value to use if the pad mode is ``BORDER_CONSTANT``.
                * If ``number``, then that value will be used.
                * If a ``tuple`` of two ``number`` s and at least one of them is
                  a ``float``, then a random number will be uniformly sampled per
                  image from the continuous interval ``[a, b]`` and used as the
                  value. If both ``number`` s are ``int`` s, the interval is
                  discrete.
                * If a ``list`` of ``number``, then a random value will be chosen
                  from the elements of the ``list`` and used as the value.
        pad_cval_mask (number, Sequence[number]): Same as pad_cval but only for masks.
        keep_size (bool):
            After cropping and padding, the result image will usually have a
            different height/width compared to the original input image. If this
            parameter is set to ``True``, then the cropped/padded image will be
            resized to the input image's size, i.e. the output shape is always identical to the input shape.
        sample_independently (bool):
            If ``False`` *and* the values for `px`/`percent` result in exactly
            *one* probability distribution for all image sides, only one single
            value will be sampled from that probability distribution and used for
            all sides. I.e. the crop/pad amount then is the same for all sides.
            If ``True``, four values will be sampled independently, one per side.
        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:
            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.
            Default: cv2.INTER_LINEAR.

    Targets:
        image, mask, bboxes, keypoints

    Image types:
        any
    """
    def __init__(self, px: Optional[Union[int, Sequence[float], Sequence[Tuple]]] = ..., percent: Optional[Union[float, Sequence[float], Sequence[Tuple]]] = ..., pad_mode: int = ..., pad_cval: Union[float, Sequence[float]] = ..., pad_cval_mask: Union[float, Sequence[float]] = ..., keep_size: bool = ..., sample_independently: bool = ..., interpolation: int = ..., always_apply: bool = ..., p: float = ...) -> None:
        ...
    
    def apply(self, img: np.ndarray, crop_params: Sequence[int] = ..., pad_params: Sequence[int] = ..., pad_value: Union[int, float] = ..., rows: int = ..., cols: int = ..., interpolation: int = ..., **params) -> np.ndarray:
        ...
    
    def apply_to_mask(self, img: np.ndarray, crop_params: Optional[Sequence[int]] = ..., pad_params: Optional[Sequence[int]] = ..., pad_value_mask: float = ..., rows: int = ..., cols: int = ..., interpolation: int = ..., **params) -> np.ndarray:
        ...
    
    def apply_to_bbox(self, bbox: BoxInternalType, crop_params: Optional[Sequence[int]] = ..., pad_params: Optional[Sequence[int]] = ..., rows: int = ..., cols: int = ..., result_rows: int = ..., result_cols: int = ..., **params) -> BoxInternalType:
        ...
    
    def apply_to_keypoint(self, keypoint: KeypointInternalType, crop_params: Optional[Sequence[int]] = ..., pad_params: Optional[Sequence[int]] = ..., rows: int = ..., cols: int = ..., result_rows: int = ..., result_cols: int = ..., **params) -> KeypointInternalType:
        ...
    
    @property
    def targets_as_params(self) -> List[str]:
        ...
    
    def get_params_dependent_on_targets(self, params) -> dict:
        ...
    
    def get_transform_init_args_names(self) -> Tuple[str, ...]:
        ...
    


class RandomCropFromBorders(DualTransform):
    """Crop bbox from image randomly cut parts from borders without resize at the end

    Args:
        crop_left (float): single float value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut
        from left side in range [0, crop_left * width)
        crop_right (float): single float value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut
        from right side in range [(1 - crop_right) * width, width)
        crop_top (float): singlefloat value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut
        from top side in range [0, crop_top * height)
        crop_bottom (float): single float value in (0.0, 1.0) range. Default 0.1. Image will be randomly cut
        from bottom side in range [(1 - crop_bottom) * height, height)
        p (float): probability of applying the transform. Default: 1.

    Targets:
        image, mask, bboxes, keypoints

    Image types:
        uint8, float32
    """
    def __init__(self, crop_left=..., crop_right=..., crop_top=..., crop_bottom=..., always_apply=..., p=...) -> None:
        ...
    
    def get_params_dependent_on_targets(self, params): # -> dict[str, int]:
        ...
    
    def apply(self, img, x_min=..., x_max=..., y_min=..., y_max=..., **params): # -> ndarray[Any, Unknown]:
        ...
    
    def apply_to_mask(self, mask, x_min=..., x_max=..., y_min=..., y_max=..., **params): # -> ndarray[Any, Unknown]:
        ...
    
    def apply_to_bbox(self, bbox, x_min=..., x_max=..., y_min=..., y_max=..., **params): # -> BoxInternalType:
        ...
    
    def apply_to_keypoint(self, keypoint, x_min=..., x_max=..., y_min=..., y_max=..., **params): # -> tuple[float, float, float, float]:
        ...
    
    @property
    def targets_as_params(self): # -> list[str]:
        ...
    
    def get_transform_init_args_names(self): # -> tuple[Literal['crop_left'], Literal['crop_right'], Literal['crop_top'], Literal['crop_bottom']]:
        ...
    


