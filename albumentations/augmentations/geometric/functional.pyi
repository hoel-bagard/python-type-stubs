"""
This type stub file was generated by pyright.
"""

from typing import List, Optional, Sequence, Tuple, Union

import numpy as np
import skimage.transform
from albumentations.augmentations.utils import angle_2pi_range, clipped, preserve_channel_dim, preserve_shape

from ...core.transforms_interface import BoxInternalType, FillValueType, ImageColorType, KeypointInternalType

__all__ = ["optical_distortion", "elastic_transform_approx", "grid_distortion", "pad", "pad_with_params", "bbox_rot90", "keypoint_rot90", "rotate", "bbox_rotate", "keypoint_rotate", "shift_scale_rotate", "keypoint_shift_scale_rotate", "bbox_shift_scale_rotate", "elastic_transform", "resize", "scale", "keypoint_scale", "py3round", "_func_max_size", "longest_max_size", "smallest_max_size", "perspective", "perspective_bbox", "rotation2DMatrixToEulerAngles", "perspective_keypoint", "_is_identity_matrix", "warp_affine", "keypoint_affine", "bbox_affine", "safe_rotate", "bbox_safe_rotate", "keypoint_safe_rotate", "piecewise_affine", "to_distance_maps", "from_distance_maps", "keypoint_piecewise_affine", "bbox_piecewise_affine", "bbox_flip", "bbox_hflip", "bbox_transpose", "bbox_vflip", "hflip", "hflip_cv2", "transpose", "keypoint_flip", "keypoint_hflip", "keypoint_transpose", "keypoint_vflip"]
def bbox_rot90(bbox: BoxInternalType, factor: int, rows: int, cols: int) -> BoxInternalType:
    """Rotates a bounding box by 90 degrees CCW (see np.rot90)

    Args:
        bbox: A bounding box tuple (x_min, y_min, x_max, y_max).
        factor: Number of CCW rotations. Must be in set {0, 1, 2, 3} See np.rot90.
        rows: Image rows.
        cols: Image cols.

    Returns:
        tuple: A bounding box tuple (x_min, y_min, x_max, y_max).

    """
    ...

@angle_2pi_range
def keypoint_rot90(keypoint: KeypointInternalType, factor: int, rows: int, cols: int, **params) -> KeypointInternalType:
    """Rotates a keypoint by 90 degrees CCW (see np.rot90)

    Args:
        keypoint: A keypoint `(x, y, angle, scale)`.
        factor: Number of CCW rotations. Must be in range [0;3] See np.rot90.
        rows: Image height.
        cols: Image width.

    Returns:
        tuple: A keypoint `(x, y, angle, scale)`.

    Raises:
        ValueError: if factor not in set {0, 1, 2, 3}

    """
    ...

@preserve_channel_dim
def rotate(img: np.ndarray, angle: float, interpolation: int = ..., border_mode: int = ..., value: Optional[ImageColorType] = ...): # -> ndarray[Unknown, Unknown]:
    ...

def bbox_rotate(bbox: BoxInternalType, angle: float, method: str, rows: int, cols: int) -> BoxInternalType:
    """Rotates a bounding box by angle degrees.

    Args:
        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.
        angle: Angle of rotation in degrees.
        method: Rotation method used. Should be one of: "largest_box", "ellipse". Default: "largest_box".
        rows: Image rows.
        cols: Image cols.

    Returns:
        A bounding box `(x_min, y_min, x_max, y_max)`.

    References:
        https://arxiv.org/abs/2109.13488

    """
    ...

@angle_2pi_range
def keypoint_rotate(keypoint, angle, rows, cols, **params): # -> tuple[Unknown, Unknown, Unknown, Unknown]:
    """Rotate a keypoint by angle.

    Args:
        keypoint (tuple): A keypoint `(x, y, angle, scale)`.
        angle (float): Rotation angle.
        rows (int): Image height.
        cols (int): Image width.

    Returns:
        tuple: A keypoint `(x, y, angle, scale)`.

    """
    ...

@preserve_channel_dim
def shift_scale_rotate(img, angle, scale, dx, dy, interpolation=..., border_mode=..., value=...): # -> ndarray[Unknown, Unknown]:
    ...

@angle_2pi_range
def keypoint_shift_scale_rotate(keypoint, angle, scale, dx, dy, rows, cols, **params): # -> tuple[Unknown, Unknown, Unknown, Unknown]:
    ...

def bbox_shift_scale_rotate(bbox, angle, scale, dx, dy, rotate_method, rows, cols, **kwargs): # -> tuple[Unknown, Unknown, Unknown, Unknown]:
    """Rotates, shifts and scales a bounding box. Rotation is made by angle degrees,
    scaling is made by scale factor and shifting is made by dx and dy.


    Args:
        bbox (tuple): A bounding box `(x_min, y_min, x_max, y_max)`.
        angle (int): Angle of rotation in degrees.
        scale (int): Scale factor.
        dx (int): Shift along x-axis in pixel units.
        dy (int): Shift along y-axis in pixel units.
        rotate_method(str): Rotation method used. Should be one of: "largest_box", "ellipse".
            Default: "largest_box".
        rows (int): Image rows.
        cols (int): Image cols.

    Returns:
        A bounding box `(x_min, y_min, x_max, y_max)`.

    """
    ...

@preserve_shape
def elastic_transform(img: np.ndarray, alpha: float, sigma: float, alpha_affine: float, interpolation: int = ..., border_mode: int = ..., value: Optional[ImageColorType] = ..., random_state: Optional[np.random.RandomState] = ..., approximate: bool = ..., same_dxdy: bool = ...): # -> ndarray[Unknown, Unknown]:
    """Elastic deformation of images as described in [Simard2003]_ (with modifications).
    Based on https://gist.github.com/ernestum/601cdf56d2b424757de5

    .. [Simard2003] Simard, Steinkraus and Platt, "Best Practices for
         Convolutional Neural Networks applied to Visual Document Analysis", in
         Proc. of the International Conference on Document Analysis and
         Recognition, 2003.
    """
    ...

@preserve_channel_dim
def resize(img, height, width, interpolation=...): # -> ndarray[Unknown, Unknown]:
    ...

@preserve_channel_dim
def scale(img: np.ndarray, scale: float, interpolation: int = ...) -> np.ndarray:
    ...

def keypoint_scale(keypoint: KeypointInternalType, scale_x: float, scale_y: float) -> KeypointInternalType:
    """Scales a keypoint by scale_x and scale_y.

    Args:
        keypoint: A keypoint `(x, y, angle, scale)`.
        scale_x: Scale coefficient x-axis.
        scale_y: Scale coefficient y-axis.

    Returns:
        A keypoint `(x, y, angle, scale)`.

    """
    ...

def py3round(number): # -> int:
    """Unified rounding in all python versions."""
    ...

@preserve_channel_dim
def longest_max_size(img: np.ndarray, max_size: int, interpolation: int) -> np.ndarray:
    ...

@preserve_channel_dim
def smallest_max_size(img: np.ndarray, max_size: int, interpolation: int) -> np.ndarray:
    ...

@preserve_channel_dim
def perspective(img: np.ndarray, matrix: np.ndarray, max_width: int, max_height: int, border_val: Union[int, float, List[int], List[float], np.ndarray], border_mode: int, keep_size: bool, interpolation: int): # -> ndarray[Unknown, Unknown]:
    ...

def perspective_bbox(bbox: BoxInternalType, height: int, width: int, matrix: np.ndarray, max_width: int, max_height: int, keep_size: bool) -> BoxInternalType:
    ...

def rotation2DMatrixToEulerAngles(matrix: np.ndarray, y_up: bool = ...) -> float:
    """
    Args:
        matrix (np.ndarray): Rotation matrix
        y_up (bool): is Y axis looks up or down
    """
    ...

@angle_2pi_range
def perspective_keypoint(keypoint: KeypointInternalType, height: int, width: int, matrix: np.ndarray, max_width: int, max_height: int, keep_size: bool) -> KeypointInternalType:
    ...

@preserve_channel_dim
def warp_affine(image: np.ndarray, matrix: skimage.transform.ProjectiveTransform, interpolation: int, cval: Union[int, float, Sequence[int], Sequence[float]], mode: int, output_shape: Sequence[int]) -> np.ndarray:
    ...

@angle_2pi_range
def keypoint_affine(keypoint: KeypointInternalType, matrix: skimage.transform.ProjectiveTransform, scale: dict) -> KeypointInternalType:
    ...

def bbox_affine(bbox: BoxInternalType, matrix: skimage.transform.ProjectiveTransform, rows: int, cols: int, output_shape: Sequence[int]) -> BoxInternalType:
    ...

@preserve_channel_dim
def safe_rotate(img: np.ndarray, matrix: np.ndarray, interpolation: int, value: FillValueType = ..., border_mode: int = ...) -> np.ndarray:
    ...

def bbox_safe_rotate(bbox: BoxInternalType, matrix: np.ndarray, cols: int, rows: int) -> BoxInternalType:
    ...

def keypoint_safe_rotate(keypoint: KeypointInternalType, matrix: np.ndarray, angle: float, scale_x: float, scale_y: float, cols: int, rows: int) -> KeypointInternalType:
    ...

@clipped
def piecewise_affine(img: np.ndarray, matrix: skimage.transform.PiecewiseAffineTransform, interpolation: int, mode: str, cval: float) -> np.ndarray:
    ...

def to_distance_maps(keypoints: Sequence[Tuple[float, float]], height: int, width: int, inverted: bool = ...) -> np.ndarray:
    """Generate a ``(H,W,N)`` array of distance maps for ``N`` keypoints.

    The ``n``-th distance map contains at every location ``(y, x)`` the
    euclidean distance to the ``n``-th keypoint.

    This function can be used as a helper when augmenting keypoints with a
    method that only supports the augmentation of images.

    Args:
        keypoint: keypoint coordinates
        height: image height
        width: image width
        inverted (bool): If ``True``, inverted distance maps are returned where each
            distance value d is replaced by ``d/(d+1)``, i.e. the distance
            maps have values in the range ``(0.0, 1.0]`` with ``1.0`` denoting
            exactly the position of the respective keypoint.

    Returns:
        (H, W, N) ndarray
            A ``float32`` array containing ``N`` distance maps for ``N``
            keypoints. Each location ``(y, x, n)`` in the array denotes the
            euclidean distance at ``(y, x)`` to the ``n``-th keypoint.
            If `inverted` is ``True``, the distance ``d`` is replaced
            by ``d/(d+1)``. The height and width of the array match the
            height and width in ``KeypointsOnImage.shape``.
    """
    ...

def from_distance_maps(distance_maps: np.ndarray, inverted: bool, if_not_found_coords: Optional[Union[Sequence[int], dict]], threshold: Optional[float] = ...) -> List[Tuple[float, float]]:
    """Convert outputs of ``to_distance_maps()`` to ``KeypointsOnImage``.
    This is the inverse of `to_distance_maps`.

    Args:
        distance_maps (np.ndarray): The distance maps. ``N`` is the number of keypoints.
        inverted (bool): Whether the given distance maps were generated in inverted mode
            (i.e. :func:`KeypointsOnImage.to_distance_maps` was called with ``inverted=True``) or in non-inverted mode.
        if_not_found_coords (tuple, list, dict or None, optional):
            Coordinates to use for keypoints that cannot be found in `distance_maps`.

            * If this is a ``list``/``tuple``, it must contain two ``int`` values.
            * If it is a ``dict``, it must contain the keys ``x`` and ``y`` with each containing one ``int`` value.
            * If this is ``None``, then the keypoint will not be added.
        threshold (float): The search for keypoints works by searching for the
            argmin (non-inverted) or argmax (inverted) in each channel. This
            parameters contains the maximum (non-inverted) or minimum (inverted) value to accept in order to view a hit
            as a keypoint. Use ``None`` to use no min/max.
        nb_channels (None, int): Number of channels of the image on which the keypoints are placed.
            Some keypoint augmenters require that information. If set to ``None``, the keypoint's shape will be set
            to ``(height, width)``, otherwise ``(height, width, nb_channels)``.
    """
    ...

def keypoint_piecewise_affine(keypoint: KeypointInternalType, matrix: skimage.transform.PiecewiseAffineTransform, h: int, w: int, keypoints_threshold: float) -> KeypointInternalType:
    ...

def bbox_piecewise_affine(bbox: BoxInternalType, matrix: skimage.transform.PiecewiseAffineTransform, h: int, w: int, keypoints_threshold: float) -> BoxInternalType:
    ...

def vflip(img: np.ndarray) -> np.ndarray:
    ...

def hflip(img: np.ndarray) -> np.ndarray:
    ...

def hflip_cv2(img: np.ndarray) -> np.ndarray:
    ...

@preserve_shape
def random_flip(img: np.ndarray, code: int) -> np.ndarray:
    ...

def transpose(img: np.ndarray) -> np.ndarray:
    ...

def rot90(img: np.ndarray, factor: int) -> np.ndarray:
    ...

def bbox_vflip(bbox: BoxInternalType, rows: int, cols: int) -> BoxInternalType:
    """Flip a bounding box vertically around the x-axis.

    Args:
        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.
        rows: Image rows.
        cols: Image cols.

    Returns:
        tuple: A bounding box `(x_min, y_min, x_max, y_max)`.

    """
    ...

def bbox_hflip(bbox: BoxInternalType, rows: int, cols: int) -> BoxInternalType:
    """Flip a bounding box horizontally around the y-axis.

    Args:
        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.
        rows: Image rows.
        cols: Image cols.

    Returns:
        A bounding box `(x_min, y_min, x_max, y_max)`.

    """
    ...

def bbox_flip(bbox: BoxInternalType, d: int, rows: int, cols: int) -> BoxInternalType:
    """Flip a bounding box either vertically, horizontally or both depending on the value of `d`.

    Args:
        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.
        d: dimension. 0 for vertical flip, 1 for horizontal, -1 for transpose
        rows: Image rows.
        cols: Image cols.

    Returns:
        A bounding box `(x_min, y_min, x_max, y_max)`.

    Raises:
        ValueError: if value of `d` is not -1, 0 or 1.

    """
    ...

def bbox_transpose(bbox: KeypointInternalType, axis: int, rows: int, cols: int) -> KeypointInternalType:
    """Transposes a bounding box along given axis.

    Args:
        bbox: A bounding box `(x_min, y_min, x_max, y_max)`.
        axis: 0 - main axis, 1 - secondary axis.
        rows: Image rows.
        cols: Image cols.

    Returns:
        A bounding box tuple `(x_min, y_min, x_max, y_max)`.

    Raises:
        ValueError: If axis not equal to 0 or 1.

    """
    ...

@angle_2pi_range
def keypoint_vflip(keypoint: KeypointInternalType, rows: int, cols: int) -> KeypointInternalType:
    """Flip a keypoint vertically around the x-axis.

    Args:
        keypoint: A keypoint `(x, y, angle, scale)`.
        rows: Image height.
        cols: Image width.

    Returns:
        tuple: A keypoint `(x, y, angle, scale)`.

    """
    ...

@angle_2pi_range
def keypoint_hflip(keypoint: KeypointInternalType, rows: int, cols: int) -> KeypointInternalType:
    """Flip a keypoint horizontally around the y-axis.

    Args:
        keypoint: A keypoint `(x, y, angle, scale)`.
        rows: Image height.
        cols: Image width.

    Returns:
        A keypoint `(x, y, angle, scale)`.

    """
    ...

def keypoint_flip(keypoint: KeypointInternalType, d: int, rows: int, cols: int) -> KeypointInternalType:
    """Flip a keypoint either vertically, horizontally or both depending on the value of `d`.

    Args:
        keypoint: A keypoint `(x, y, angle, scale)`.
        d: Number of flip. Must be -1, 0 or 1:
            * 0 - vertical flip,
            * 1 - horizontal flip,
            * -1 - vertical and horizontal flip.
        rows: Image height.
        cols: Image width.

    Returns:
        A keypoint `(x, y, angle, scale)`.

    Raises:
        ValueError: if value of `d` is not -1, 0 or 1.

    """
    ...

def keypoint_transpose(keypoint: KeypointInternalType) -> KeypointInternalType:
    """Rotate a keypoint by angle.

    Args:
        keypoint: A keypoint `(x, y, angle, scale)`.

    Returns:
        A keypoint `(x, y, angle, scale)`.

    """
    ...

@preserve_channel_dim
def pad(img: np.ndarray, min_height: int, min_width: int, border_mode: int = ..., value: Optional[ImageColorType] = ...) -> np.ndarray:
    ...

@preserve_channel_dim
def pad_with_params(img: np.ndarray, h_pad_top: int, h_pad_bottom: int, w_pad_left: int, w_pad_right: int, border_mode: int = ..., value: Optional[ImageColorType] = ...) -> np.ndarray:
    ...

@preserve_shape
def optical_distortion(img: np.ndarray, k: int = ..., dx: int = ..., dy: int = ..., interpolation: int = ..., border_mode: int = ..., value: Optional[ImageColorType] = ...) -> np.ndarray:
    """Barrel / pincushion distortion. Unconventional augment.

    Reference:
        |  https://stackoverflow.com/questions/6199636/formulas-for-barrel-pincushion-distortion
        |  https://stackoverflow.com/questions/10364201/image-transformation-in-opencv
        |  https://stackoverflow.com/questions/2477774/correcting-fisheye-distortion-programmatically
        |  http://www.coldvision.io/2017/03/02/advanced-lane-finding-using-opencv/
    """
    ...

@preserve_shape
def grid_distortion(img: np.ndarray, num_steps: int = ..., xsteps: Tuple = ..., ysteps: Tuple = ..., interpolation: int = ..., border_mode: int = ..., value: Optional[ImageColorType] = ...) -> np.ndarray:
    """Perform a grid distortion of an input image.

    Reference:
        http://pythology.blogspot.sg/2014/03/interpolation-on-regular-distorted-grid.html
    """
    ...

@preserve_shape
def elastic_transform_approx(img: np.ndarray, alpha: float, sigma: float, alpha_affine: float, interpolation: int = ..., border_mode: int = ..., value: Optional[ImageColorType] = ..., random_state: Optional[np.random.RandomState] = ...) -> np.ndarray:
    """Elastic deformation of images as described in [Simard2003]_ (with modifications for speed).
    Based on https://gist.github.com/ernestum/601cdf56d2b424757de5

    .. [Simard2003] Simard, Steinkraus and Platt, "Best Practices for
         Convolutional Neural Networks applied to Visual Document Analysis", in
         Proc. of the International Conference on Document Analysis and
         Recognition, 2003.
    """
    ...

