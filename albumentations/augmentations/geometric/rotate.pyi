"""
This type stub file was generated by pyright.
"""

from typing import Any, Dict, List, Optional, Sequence, Tuple, Union

import numpy as np

from ...core.transforms_interface import (BoxInternalType, DualTransform,
                                          FillValueType, KeypointInternalType)

__all__ = ["Rotate", "RandomRotate90", "SafeRotate"]
class RandomRotate90(DualTransform):
    """Randomly rotate the input by 90 degrees zero or more times.

    Args:
        p (float): probability of applying the transform. Default: 0.5.

    Targets:
        image, mask, bboxes, keypoints

    Image types:
        uint8, float32
    """
    def apply(self, img, factor=..., **params): # -> NDArray[Unknown]:
        """
        Args:
            factor (int): number of times the input will be rotated by 90 degrees.
        """
        ...
    
    def get_params(self): # -> dict[str, int]:
        ...
    
    def apply_to_bbox(self, bbox, factor=..., **params): # -> BoxInternalType:
        ...
    
    def apply_to_keypoint(self, keypoint, factor=..., **params): # -> KeypointInternalType:
        ...
    
    def get_transform_init_args_names(self): # -> tuple[()]:
        ...
    


class Rotate(DualTransform):
    """Rotate the input by an angle selected randomly from the uniform distribution.

    Args:
        limit ((int, int) or int): range from which a random angle is picked. If limit is a single int
            an angle is picked from (-limit, limit). Default: (-90, 90)
        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:
            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.
            Default: cv2.INTER_LINEAR.
        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:
            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.
            Default: cv2.BORDER_REFLECT_101
        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.
        mask_value (int, float,
                    list of ints,
                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.
        rotate_method (str): rotation method used for the bounding boxes. Should be one of "largest_box" or "ellipse".
            Default: "largest_box"
        crop_border (bool): If True would make a largest possible crop within rotated image
        p (float): probability of applying the transform. Default: 0.5.

    Targets:
        image, mask, bboxes, keypoints

    Image types:
        uint8, float32
    """
    def __init__(self, limit=..., interpolation=..., border_mode=..., value=..., mask_value=..., rotate_method=..., crop_border=..., always_apply=..., p=...) -> None:
        ...
    
    def apply(self, img, angle=..., interpolation=..., x_min=..., x_max=..., y_min=..., y_max=..., **params): # -> ndarray[Any, Unknown] | ndarray[Unknown, Unknown]:
        ...
    
    def apply_to_mask(self, img, angle=..., x_min=..., x_max=..., y_min=..., y_max=..., **params): # -> ndarray[Any, Unknown] | ndarray[Unknown, Unknown]:
        ...
    
    def apply_to_bbox(self, bbox, angle=..., x_min=..., x_max=..., y_min=..., y_max=..., cols=..., rows=..., **params): # -> BoxInternalType:
        ...
    
    def apply_to_keypoint(self, keypoint, angle=..., x_min=..., x_max=..., y_min=..., y_max=..., cols=..., rows=..., **params): # -> tuple[float, float, float, float]:
        ...
    
    @property
    def targets_as_params(self) -> List[str]:
        ...
    
    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -> Dict[str, Any]:
        ...
    
    def get_transform_init_args_names(self): # -> tuple[Literal['limit'], Literal['interpolation'], Literal['border_mode'], Literal['value'], Literal['mask_value'], Literal['rotate_method'], Literal['crop_border']]:
        ...
    


class SafeRotate(DualTransform):
    """Rotate the input inside the input's frame by an angle selected randomly from the uniform distribution.

    The resulting image may have artifacts in it. After rotation, the image may have a different aspect ratio, and
    after resizing, it returns to its original shape with the original aspect ratio of the image. For these reason we
    may see some artifacts.

    Args:
        limit ((int, int) or int): range from which a random angle is picked. If limit is a single int
            an angle is picked from (-limit, limit). Default: (-90, 90)
        interpolation (OpenCV flag): flag that is used to specify the interpolation algorithm. Should be one of:
            cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_AREA, cv2.INTER_LANCZOS4.
            Default: cv2.INTER_LINEAR.
        border_mode (OpenCV flag): flag that is used to specify the pixel extrapolation method. Should be one of:
            cv2.BORDER_CONSTANT, cv2.BORDER_REPLICATE, cv2.BORDER_REFLECT, cv2.BORDER_WRAP, cv2.BORDER_REFLECT_101.
            Default: cv2.BORDER_REFLECT_101
        value (int, float, list of ints, list of float): padding value if border_mode is cv2.BORDER_CONSTANT.
        mask_value (int, float,
                    list of ints,
                    list of float): padding value if border_mode is cv2.BORDER_CONSTANT applied for masks.
        p (float): probability of applying the transform. Default: 0.5.

    Targets:
        image, mask, bboxes, keypoints

    Image types:
        uint8, float32
    """
    def __init__(self, limit: Union[float, Tuple[float, float]] = ..., interpolation: int = ..., border_mode: int = ..., value: FillValueType = ..., mask_value: Optional[Union[int, float, Sequence[int], Sequence[float]]] = ..., always_apply: bool = ..., p: float = ...) -> None:
        ...
    
    def apply(self, img: np.ndarray, matrix: np.ndarray = ..., **params) -> np.ndarray:
        ...
    
    def apply_to_mask(self, img: np.ndarray, matrix: np.ndarray = ..., **params) -> np.ndarray:
        ...
    
    def apply_to_bbox(self, bbox: BoxInternalType, cols: int = ..., rows: int = ..., **params) -> BoxInternalType:
        ...
    
    def apply_to_keypoint(self, keypoint: KeypointInternalType, angle: float = ..., scale_x: float = ..., scale_y: float = ..., cols: int = ..., rows: int = ..., **params) -> KeypointInternalType:
        ...
    
    @property
    def targets_as_params(self) -> List[str]:
        ...
    
    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -> Dict[str, Any]:
        ...
    
    def get_transform_init_args_names(self) -> Tuple[str, str, str, str, str]:
        ...
    


