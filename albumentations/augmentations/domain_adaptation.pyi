"""
This type stub file was generated by pyright.
"""

from typing import Callable, List, Tuple, Union

import numpy as np
from albumentations.augmentations.utils import clipped, preserve_shape

from ..core.transforms_interface import ImageOnlyTransform


__all__ = ["HistogramMatching", "FDA", "PixelDistributionAdaptation", "fourier_domain_adaptation", "apply_histogram", "adapt_pixel_distribution"]
@clipped
@preserve_shape
def fourier_domain_adaptation(img: np.ndarray, target_img: np.ndarray, beta: float) -> np.ndarray:
    """
    Fourier Domain Adaptation from https://github.com/YanchaoYang/FDA

    Args:
        img:  source image
        target_img:  target image for domain adaptation
        beta: coefficient from source paper

    Returns:
        transformed image

    """
    ...

@preserve_shape
def apply_histogram(img: np.ndarray, reference_image: np.ndarray, blend_ratio: float) -> np.ndarray:
    ...

@preserve_shape
def adapt_pixel_distribution(img: np.ndarray, ref: np.ndarray, transform_type: str = ..., weight: float = ...) -> np.ndarray:
    ...

class HistogramMatching(ImageOnlyTransform):
    """
    Apply histogram matching. It manipulates the pixels of an input image so that its histogram matches
    the histogram of the reference image. If the images have multiple channels, the matching is done independently
    for each channel, as long as the number of channels is equal in the input image and the reference.

    Histogram matching can be used as a lightweight normalisation for image processing,
    such as feature matching, especially in circumstances where the images have been taken from different
    sources or in different conditions (i.e. lighting).

    See:
        https://scikit-image.org/docs/dev/auto_examples/color_exposure/plot_histogram_matching.html

    Args:
        reference_images (List[str] or List(np.ndarray)): List of file paths for reference images
            or list of reference images.
        blend_ratio (float, float): Tuple of min and max blend ratio. Matched image will be blended with original
            with random blend factor for increased diversity of generated images.
        read_fn (Callable): Used-defined function to read image. Function should get image path and return numpy
            array of image pixels.
        p (float): probability of applying the transform. Default: 1.0.

    Targets:
        image

    Image types:
        uint8, uint16, float32
    """
    def __init__(self, reference_images: List[Union[str, np.ndarray]], blend_ratio=..., read_fn=..., always_apply=..., p=...) -> None:
        ...
    
    def apply(self, img, reference_image=..., blend_ratio=..., **params): # -> ndarray[Unknown, Unknown]:
        ...
    
    def get_params(self): # -> dict[str, NDArray[uint8] | float]:
        ...
    
    def get_transform_init_args_names(self): # -> tuple[Literal['reference_images'], Literal['blend_ratio'], Literal['read_fn']]:
        ...
    


class FDA(ImageOnlyTransform):
    """
    Fourier Domain Adaptation from https://github.com/YanchaoYang/FDA
    Simple "style transfer".

    Args:
        reference_images (List[str] or List(np.ndarray)): List of file paths for reference images
            or list of reference images.
        beta_limit (float or tuple of float): coefficient beta from paper. Recommended less 0.3.
        read_fn (Callable): Used-defined function to read image. Function should get image path and return numpy
            array of image pixels.

    Targets:
        image

    Image types:
        uint8, float32

    Reference:
        https://github.com/YanchaoYang/FDA
        https://openaccess.thecvf.com/content_CVPR_2020/papers/Yang_FDA_Fourier_Domain_Adaptation_for_Semantic_Segmentation_CVPR_2020_paper.pdf

    Example:
        >>> import numpy as np
        >>> import albumentations as A
        >>> image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)
        >>> target_image = np.random.randint(0, 256, [100, 100, 3], dtype=np.uint8)
        >>> aug = A.Compose([A.FDA([target_image], p=1, read_fn=lambda x: x)])
        >>> result = aug(image=image)

    """
    def __init__(self, reference_images: List[Union[str, np.ndarray]], beta_limit=..., read_fn=..., always_apply=..., p=...) -> None:
        ...
    
    def apply(self, img, target_image=..., beta=..., **params):
        ...
    
    def get_params_dependent_on_targets(self, params): # -> dict[str, NDArray[uint8]]:
        ...
    
    def get_params(self): # -> dict[str, float]:
        ...
    
    @property
    def targets_as_params(self): # -> list[str]:
        ...
    
    def get_transform_init_args_names(self): # -> tuple[Literal['reference_images'], Literal['beta_limit'], Literal['read_fn']]:
        ...
    


class PixelDistributionAdaptation(ImageOnlyTransform):
    """
    Another naive and quick pixel-level domain adaptation. It fits a simple transform (such as PCA, StandardScaler
    or MinMaxScaler) on both original and reference image, transforms original image with transform trained on this
    image and then performs inverse transformation using transform fitted on reference image.

    Args:
        reference_images (List[str] or List(np.ndarray)): List of file paths for reference images
            or list of reference images.
        blend_ratio (float, float): Tuple of min and max blend ratio. Matched image will be blended with original
            with random blend factor for increased diversity of generated images.
        read_fn (Callable): Used-defined function to read image. Function should get image path and return numpy
            array of image pixels. Usually it's default `read_rgb_image` when images paths are used as reference,
            otherwise it could be identity function `lambda x: x` if reference images have been read in advance.
        transform_type (str): type of transform; "pca", "standard", "minmax" are allowed.
        p (float): probability of applying the transform. Default: 1.0.

    Targets:
        image

    Image types:
        uint8, float32

    See also: https://github.com/arsenyinfo/qudida
    """
    def __init__(self, reference_images: List[Union[str, np.ndarray]], blend_ratio: Tuple[float, float] = ..., read_fn: Callable[[Union[str, np.ndarray]], np.ndarray] = ..., transform_type: str = ..., always_apply=..., p=...) -> None:
        ...
    
    def ensure_uint8(self, img: np.ndarray) -> Tuple[np.ndarray, bool]:
        ...
    
    def apply(self, img, reference_image, blend_ratio, **params):
        ...
    
    def get_params(self): # -> dict[str, ndarray[Unknown, Unknown] | float]:
        ...
    
    def get_transform_init_args_names(self): # -> tuple[Literal['reference_images'], Literal['blend_ratio'], Literal['read_fn'], Literal['transform_type']]:
        ...
    


