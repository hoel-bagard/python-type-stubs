"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Dict, List, Optional, Sequence, Tuple, Union

import numpy as np

from .serialization import Serializable

__all__ = ["to_tuple", "BasicTransform", "DualTransform", "ImageOnlyTransform", "NoOp", "BoxType", "KeypointType", "ImageColorType", "ScaleFloatType", "ScaleIntType", "ImageColorType"]
NumType = Union[int, float, np.ndarray]
BoxInternalType = Tuple[float, float, float, float]
BoxType = Union[BoxInternalType, Tuple[float, float, float, float, Any]]
KeypointInternalType = Tuple[float, float, float, float]
KeypointType = Union[KeypointInternalType, Tuple[float, float, float, float, Any]]
ImageColorType = Union[float, Sequence[float]]
ScaleFloatType = Union[float, Tuple[float, float]]
ScaleIntType = Union[int, Tuple[int, int]]
FillValueType = Optional[Union[int, float, Sequence[int], Sequence[float]]]
def to_tuple(param, low=..., bias=...): # -> tuple[Unknown, ...] | tuple[int | float, ...]:
    """Convert input argument to min-max tuple
    Args:
        param (scalar, tuple or list of 2+ elements): Input value.
            If value is scalar, return value would be (offset - value, offset + value).
            If value is tuple, return value would be value + offset (broadcasted).
        low:  Second element of tuple can be passed as optional argument
        bias: An offset factor added to each element
    """
    ...

class BasicTransform(Serializable):
    call_backup = ...
    interpolation: Any
    fill_value: Any
    mask_fill_value: Any
    def __init__(self, always_apply: bool = ..., p: float = ...) -> None:
        ...
    
    def __call__(self, *args, force_apply: bool = ..., **kwargs) -> Dict[str, Any]:
        ...
    
    def apply_with_params(self, params: Dict[str, Any], **kwargs) -> Dict[str, Any]:
        ...
    
    def set_deterministic(self, flag: bool, save_key: str = ...) -> BasicTransform:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def apply(self, img: np.ndarray, **params) -> np.ndarray:
        ...
    
    def get_params(self) -> Dict:
        ...
    
    @property
    def targets(self) -> Dict[str, Callable]:
        ...
    
    def update_params(self, params: Dict[str, Any], **kwargs) -> Dict[str, Any]:
        ...
    
    @property
    def target_dependence(self) -> Dict:
        ...
    
    def add_targets(self, additional_targets: Dict[str, str]): # -> None:
        """Add targets to transform them the same way as one of existing targets
        ex: {'target_image': 'image'}
        ex: {'obj1_mask': 'mask', 'obj2_mask': 'mask'}
        by the way you must have at least one object with key 'image'

        Args:
            additional_targets (dict): keys - new target name, values - old target name. ex: {'image2': 'image'}
        """
        ...
    
    @property
    def targets_as_params(self) -> List[str]:
        ...
    
    def get_params_dependent_on_targets(self, params: Dict[str, Any]) -> Dict[str, Any]:
        ...
    
    @classmethod
    def get_class_fullname(cls) -> str:
        ...
    
    @classmethod
    def is_serializable(cls): # -> Literal[True]:
        ...
    
    def get_transform_init_args_names(self) -> Tuple[str, ...]:
        ...
    
    def get_base_init_args(self) -> Dict[str, Any]:
        ...
    
    def get_transform_init_args(self) -> Dict[str, Any]:
        ...
    
    def get_dict_with_id(self) -> Dict[str, Any]:
        ...
    


class DualTransform(BasicTransform):
    """Transform for segmentation task."""
    @property
    def targets(self) -> Dict[str, Callable]:
        ...
    
    def apply_to_bbox(self, bbox: BoxInternalType, **params) -> BoxInternalType:
        ...
    
    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params) -> KeypointInternalType:
        ...
    
    def apply_to_bboxes(self, bboxes: Sequence[BoxType], **params) -> List[BoxType]:
        ...
    
    def apply_to_keypoints(self, keypoints: Sequence[KeypointType], **params) -> List[KeypointType]:
        ...
    
    def apply_to_mask(self, img: np.ndarray, **params) -> np.ndarray:
        ...
    
    def apply_to_masks(self, masks: Sequence[np.ndarray], **params) -> List[np.ndarray]:
        ...
    


class ImageOnlyTransform(BasicTransform):
    """Transform applied to image only."""
    @property
    def targets(self) -> Dict[str, Callable]:
        ...
    


class NoOp(DualTransform):
    """Does nothing"""
    def apply_to_keypoint(self, keypoint: KeypointInternalType, **params) -> KeypointInternalType:
        ...
    
    def apply_to_bbox(self, bbox: BoxInternalType, **params) -> BoxInternalType:
        ...
    
    def apply(self, img: np.ndarray, **params) -> np.ndarray:
        ...
    
    def apply_to_mask(self, img: np.ndarray, **params) -> np.ndarray:
        ...
    
    def get_transform_init_args_names(self) -> Tuple:
        ...
    


