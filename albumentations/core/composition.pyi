"""
This type stub file was generated by pyright.
"""

import typing

from .bbox_utils import BboxParams
from .keypoints_utils import KeypointParams
from .serialization import Serializable
from .transforms_interface import BasicTransform


__all__ = ["BaseCompose", "Compose", "SomeOf", "OneOf", "OneOrOther", "BboxParams", "KeypointParams", "ReplayCompose", "Sequential"]
REPR_INDENT_STEP = ...
TransformType = typing.Union[BasicTransform, "BaseCompose"]
TransformsSeqType = typing.Sequence[TransformType]
def get_always_apply(transforms: typing.Union[BaseCompose, TransformsSeqType]) -> TransformsSeqType:
    ...

class BaseCompose(Serializable):
    def __init__(self, transforms: TransformsSeqType, p: float) -> None:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __call__(self, *args, **data) -> typing.Dict[str, typing.Any]:
        ...
    
    def __getitem__(self, item: int) -> TransformType:
        ...
    
    def __repr__(self) -> str:
        ...
    
    def indented_repr(self, indent: int = ...) -> str:
        ...
    
    @classmethod
    def get_class_fullname(cls) -> str:
        ...
    
    @classmethod
    def is_serializable(cls) -> bool:
        ...
    
    def get_dict_with_id(self) -> typing.Dict[str, typing.Any]:
        ...
    
    def add_targets(self, additional_targets: typing.Optional[typing.Dict[str, str]]) -> None:
        ...
    
    def set_deterministic(self, flag: bool, save_key: str = ...) -> None:
        ...
    


class Compose(BaseCompose):
    """Compose transforms and handle all transformations regarding bounding boxes

    Args:
        transforms (list): list of transformations to compose.
        bbox_params (BboxParams): Parameters for bounding boxes transforms
        keypoint_params (KeypointParams): Parameters for keypoints transforms
        additional_targets (dict): Dict with keys - new target name, values - old target name. ex: {'image2': 'image'}
        p (float): probability of applying all list of transforms. Default: 1.0.
    """
    def __init__(self, transforms: TransformsSeqType, bbox_params: typing.Optional[typing.Union[dict, BboxParams]] = ..., keypoint_params: typing.Optional[typing.Union[dict, KeypointParams]] = ..., additional_targets: typing.Optional[typing.Dict[str, str]] = ..., p: float = ...) -> None:
        ...
    
    def __call__(self, *args, force_apply: bool = ..., **data) -> typing.Dict[str, typing.Any]:
        ...
    
    def get_dict_with_id(self) -> typing.Dict[str, typing.Any]:
        ...
    


class OneOf(BaseCompose):
    """Select one of transforms to apply. Selected transform will be called with `force_apply=True`.
    Transforms probabilities will be normalized to one 1, so in this case transforms probabilities works as weights.

    Args:
        transforms (list): list of transformations to compose.
        p (float): probability of applying selected transform. Default: 0.5.
    """
    def __init__(self, transforms: TransformsSeqType, p: float = ...) -> None:
        ...
    
    def __call__(self, *args, force_apply: bool = ..., **data) -> typing.Dict[str, typing.Any]:
        ...
    


class SomeOf(BaseCompose):
    """Select N transforms to apply. Selected transforms will be called with `force_apply=True`.
    Transforms probabilities will be normalized to one 1, so in this case transforms probabilities works as weights.

    Args:
        transforms (list): list of transformations to compose.
        n (int): number of transforms to apply.
        replace (bool): Whether the sampled transforms are with or without replacement. Default: True.
        p (float): probability of applying selected transform. Default: 1.
    """
    def __init__(self, transforms: TransformsSeqType, n: int, replace: bool = ..., p: float = ...) -> None:
        ...
    
    def __call__(self, *args, force_apply: bool = ..., **data) -> typing.Dict[str, typing.Any]:
        ...
    


class OneOrOther(BaseCompose):
    """Select one or another transform to apply. Selected transform will be called with `force_apply=True`."""
    def __init__(self, first: typing.Optional[TransformType] = ..., second: typing.Optional[TransformType] = ..., transforms: typing.Optional[TransformsSeqType] = ..., p: float = ...) -> None:
        ...
    
    def __call__(self, *args, force_apply: bool = ..., **data) -> typing.Dict[str, typing.Any]:
        ...
    


class PerChannel(BaseCompose):
    """Apply transformations per-channel

    Args:
        transforms (list): list of transformations to compose.
        channels (sequence): channels to apply the transform to. Pass None to apply to all.
                         Default: None (apply to all)
        p (float): probability of applying the transform. Default: 0.5.
    """
    def __init__(self, transforms: TransformsSeqType, channels: typing.Optional[typing.Sequence[int]] = ..., p: float = ...) -> None:
        ...
    
    def __call__(self, *args, force_apply: bool = ..., **data) -> typing.Dict[str, typing.Any]:
        ...
    


class ReplayCompose(Compose):
    def __init__(self, transforms: TransformsSeqType, bbox_params: typing.Optional[typing.Union[dict, BboxParams]] = ..., keypoint_params: typing.Optional[typing.Union[dict, KeypointParams]] = ..., additional_targets: typing.Optional[typing.Dict[str, str]] = ..., p: float = ..., save_key: str = ...) -> None:
        ...
    
    def __call__(self, *args, force_apply: bool = ..., **kwargs) -> typing.Dict[str, typing.Any]:
        ...
    
    @staticmethod
    def replay(saved_augmentations: typing.Dict[str, typing.Any], **kwargs) -> typing.Dict[str, typing.Any]:
        ...
    
    def fill_with_params(self, serialized: dict, all_params: dict) -> None:
        ...
    
    def fill_applied(self, serialized: typing.Dict[str, typing.Any]) -> bool:
        ...
    


class Sequential(BaseCompose):
    """Sequentially applies all transforms to targets.

    Note:
        This transform is not intended to be a replacement for `Compose`. Instead, it should be used inside `Compose`
        the same way `OneOf` or `OneOrOther` are used. For instance, you can combine `OneOf` with `Sequential` to
        create an augmentation pipeline that contains multiple sequences of augmentations and applies one randomly
        chose sequence to input data (see the `Example` section for an example definition of such pipeline).

    Example:
        >>> import albumentations as A
        >>> transform = A.Compose([
        >>>    A.OneOf([
        >>>        A.Sequential([
        >>>            A.HorizontalFlip(p=0.5),
        >>>            A.ShiftScaleRotate(p=0.5),
        >>>        ]),
        >>>        A.Sequential([
        >>>            A.VerticalFlip(p=0.5),
        >>>            A.RandomBrightnessContrast(p=0.5),
        >>>        ]),
        >>>    ], p=1)
        >>> ])
    """
    def __init__(self, transforms: TransformsSeqType, p: float = ...) -> None:
        ...
    
    def __call__(self, *args, **data) -> typing.Dict[str, typing.Any]:
        ...
    


